# 最长公共子序列

## 问题特点

- 最值问题用动态规划
- DP 特点
  - 先以递归自顶向下发现子问题之间的树状结构（状态转移方程）
  - DP 自底向上迭代求解问题
  - 局部最优与全局最优一致
  - 二维 DP 数组 `dp[i][j]`

## 动态规划五步曲

### 1. 确定 DP 数组的含义

`dp[i][j]` 表示字符串 `text1` 的前 `i` 个字符（即 `text1[0...i-1]`）和字符串 `text2` 的前 `j` 个字符（即 `text2[0...j-1]`）的最长公共子序列长度。

### 2. 确定 DP 数组的递推公式

状态转移方程根据 `text1[i-1]` 和 `text2[j-1]` 是否相等来确定：

```javascript
if (text1[i-1] === text2[j-1]) {
  dp[i][j] = dp[i-1][j-1] + 1;
} else {
  dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
}
```

### 3. 确定 DP 数组的初始化

```javascript
// 二维数组初始化
dp[0][j] = 0, dp[i][0] = 0

// 或使用一维数组优化
const m = text1.length;
const n = text2.length;
const dp = Array(n + 1).fill(0); // 一维数组，存储上一行状态
```

### 4. 确定 DP 数组的遍历顺序

从左到右，从上到下遍历。

### 5. 确定 DP 数组的结果

返回 `dp[m][n]`，其中 `m` 和 `n` 分别为两个字符串的长度。最后一项即为最长公共子序列的长度。
