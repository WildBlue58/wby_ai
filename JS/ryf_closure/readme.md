# 阮一峰closure

- 闭包是核心考点和难点
- 闭包可以帮助外部读取函数内部的变量
- 声明不带 var 全局
  语言精粹 The Good Parts The Bad Parts
- 如何介绍闭包
  - 函数嵌套函数(作用域链的嵌套)
    f2 在 f1 的里面 形成了一个闭包
  - 内部函数要返回
  - 闭包也叫背包 自由变量不会销毁
    执行先后顺序带来的
    垃圾回收机制 **引用**计数
  - 闭包可能带来内存的泄露
  - 内层函数叫闭包函数

闭包就是将函数内部和函数外部连接起来的桥梁

## 闭包的用途

- 读取函数内部的变量
- 让这些变量的值始终保持在内存中
- 怎么说明外部函数的自由变量不会销毁？
  多次执行闭包函数，可以观察
  垃圾回收机制(引用计数)

## 注意？

- 闭包内存消耗比较大，可能内存泄漏
  在退出函数之前，将不使用的局部变量全部销毁
    = null delete
- 闭包会在父函数外部，改变父函数内部变量的值。
  - 不确定性 **自由**
  - 自由是生命周期

## 代码示例详解

### 1.js - 作用域基础
```javascript
// 作用域
// 作用域链 内部的可以访问外部
// 函数外部无法读取函数内的局部变量？
// 全局作用域
var n = 999;

function f1() { 
    // 没有使用var 申明全局
    b = 123
    // 函数作用域名
    {
        // 块级作用域
        let a = 1;
    }
    console.log(n);
}

f1();
console.log(b);
```

**关键点：**
- 全局作用域：`var n = 999` 在全局可访问
- 函数作用域：`f1()` 内部可以访问外部的 `n`
- 块级作用域：`let a = 1` 只在 `{}` 内有效
- 隐式全局变量：`b = 123` 没有 `var` 声明，自动成为全局变量

### 2.js - 闭包基础实现
```javascript
// 让局部变量可以在全局访问
function f1() {
    // 局部变量
    var n = 999;// 自由变量
    function f2() {
        console.log(n);
    }
    return f2;
}
```

**关键点：**
- `f1()` 内部定义了局部变量 `n = 999`
- `f2()` 是内部函数，可以访问外部函数的变量 `n`
- 返回 `f2` 函数，使得外部可以访问内部的变量
- `n` 成为自由变量，被闭包捕获

### 3.js - 闭包状态保持
```javascript
function f1(){
    var n = 999;
    nAdd = function(){
        n += 1;
    }
    function f2(){
        console.log(n);
    }
    // window.nAdd = f1.nAdd
    return f2;
}
var result = f1();
result();
nAdd();
result();
```

**关键点：**
- `n` 变量在闭包中被保持
- `nAdd` 函数可以修改闭包中的变量 `n`
- 多次调用 `result()` 可以看到 `n` 的值被保持和修改
- 演示了闭包如何让变量在内存中持久化

### 4.html - this 指向问题
```html
<script>
    var name = "The Window";
    var object = {
        name: "My Object",
        getNameFunc: function(){
            var that = this;
            return function(){
                return that.name;
            }
        }
    }
    alert(object.getNameFunc()());
</script>
```

**关键点：**
- 闭包中的 `this` 指向问题
- 使用 `var that = this` 保存正确的 `this` 引用
- 避免闭包中 `this` 指向 `window` 的问题
- 确保返回的函数能正确访问对象的属性

## 闭包的核心概念

### 1. 自由变量
- 在函数内部使用，但既不是函数参数也不是函数局部变量的变量
- 闭包会捕获这些自由变量，使其在函数执行完毕后仍然存在

### 2. 词法作用域
- 函数的作用域在函数定义时就确定了
- 内部函数可以访问外部函数的作用域

### 3. 内存管理
- 闭包会阻止垃圾回收机制回收被引用的变量
- 需要注意内存泄漏问题

## 实际应用场景

1. **数据私有化**：创建私有变量和方法
2. **函数工厂**：创建具有特定配置的函数
3. **模块模式**：实现模块化编程
4. **事件处理**：在事件回调中保持状态
5. **防抖节流**：控制函数执行频率

## 性能考虑

- 闭包会占用更多内存
- 过度使用可能导致内存泄漏
- 在适当时候手动解除引用：`variable = null`
