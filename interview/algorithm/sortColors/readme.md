# 颜色分类

## 问题描述

给定一个包含红色、白色和蓝色，一共 `n` 个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色的顺序排列。

此题中，我们使用整数 `0`、`1` 和 `2` 分别表示红色、白色和蓝色。

**注意**：不能使用代码库中的排序函数来解决这道题。

**示例 1：**

```text
输入: nums = [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
```

**示例 2：**

```text
输入: nums = [2,0,1]
输出: [0,1,2]
```

**示例 3：**

```text
输入: nums = [0]
输出: [0]
```

**约束条件：**

- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

## 算法标签

- 双指针 ⭐ (最优解)
- 三路快排（Dutch National Flag Problem）
- 原地排序

## 核心思想

### 为什么不能直接排序？

题目要求**原地排序**且**空间复杂度为 O(1)**，如果使用先统计再填充的方法，虽然时间复杂度是 O(n)，但需要额外的空间来存储计数，不满足要求。

### 三路快排（Dutch National Flag Problem）

三路快排是一种优化的快速排序算法，它通过将数组划分为小于、等于和大于基准值的三部分，特别有效地提升了处理大量重复元素时的排序效率。

对于颜色分类问题，我们需要将数组划分为三个区域：

- **红色区域**（0）：`[0, left)`
- **白色区域**（1）：`[left, i)`
- **蓝色区域**（2）：`(right, n-1]`

### 指针定义

- **左指针 `left`**：`[0, left)` 区间内的元素都是红色（0），`left` 指向红色区域的右边界（下一个红色元素应该放置的位置）
- **右指针 `right`**：`(right, n-1]` 区间内的元素都是蓝色（2），`right` 指向蓝色区域的左边界（下一个蓝色元素应该放置的位置）
- **遍历指针 `i`**：当前正在处理的元素位置

## 算法步骤

1. **初始化**：
   - `left = 0`：红色区域的右边界
   - `right = nums.length - 1`：蓝色区域的左边界
   - `i = 0`：当前遍历位置

2. **遍历数组**（`i <= right`）：
   - **如果 `nums[i] === 0`**（红色）：
     - 交换 `nums[i]` 和 `nums[left]`
     - `left++`：红色区域向右扩展
     - `i++`：继续处理下一个元素
   - **如果 `nums[i] === 1`**（白色）：
     - `i++`：白色元素已经在正确位置，继续处理下一个
   - **如果 `nums[i] === 2`**（蓝色）：
     - 交换 `nums[i]` 和 `nums[right]`
     - `right--`：蓝色区域向左扩展
     - **注意**：此时 `i` 不增加，因为交换后的 `nums[i]` 可能是 0 或 1，需要再次判断

3. **终止条件**：当 `i > right` 时，所有元素都已处理完毕

## 代码实现

```1:18:interview/algorithm/sortColors/1.js
function sortColors(nums) {
  let left = 0;
  let right = nums.length = 1;
  let i = 0;

  while (i <= right) {
    if (nums[i] === 0) {
      [nums[i], nums[left]] = [nums[left], nums[i]];
      left++;
      i++;
    } else if (nums[i] === 1) {
      i++;
    } else if (nums[i] === 2) {
      [nums[i], nums[right]] = [nums[right], nums[i]];
      right--;
    }
  }
}
```

**注意**：代码第 3 行存在 bug，应为 `let right = nums.length - 1;`

### 修正后的代码

```javascript
function sortColors(nums) {
  let left = 0;
  let right = nums.length - 1;  // 修正：应该是减号
  let i = 0;

  while (i <= right) {
    if (nums[i] === 0) {
      [nums[i], nums[left]] = [nums[left], nums[i]];
      left++;
      i++;
    } else if (nums[i] === 1) {
      i++;
    } else if (nums[i] === 2) {
      [nums[i], nums[right]] = [nums[right], nums[i]];
      right--;
      // 注意：这里 i 不增加，因为交换后的元素需要重新判断
    }
  }
}
```

## 关键点解析

### 为什么遇到 2 时 `i` 不增加？

当 `nums[i] === 2` 时，我们将 `nums[i]` 与 `nums[right]` 交换。交换后：

- `nums[right]` 现在是 2（蓝色），已经在正确位置
- `nums[i]` 变成了原来 `nums[right]` 的值，可能是 0、1 或 2

由于我们不知道交换后的 `nums[i]` 是什么值，需要再次判断，所以 `i` 不能增加。

### 为什么遇到 0 时 `i` 要增加？

当 `nums[i] === 0` 时，交换后：

- `nums[left]` 现在是 0（红色），已经在正确位置
- `nums[i]` 变成了原来 `nums[left]` 的值

由于 `left <= i`，原来 `nums[left]` 的值只可能是：

- **0**：已经在正确位置，`i++` 继续处理下一个
- **1**：已经在正确位置（白色区域），`i++` 继续处理下一个

所以交换后 `nums[i]` 一定是 0 或 1，都在正确位置，可以安全地 `i++`。

## 复杂度分析

- **时间复杂度**：O(n)，只需要遍历一次数组
- **空间复杂度**：O(1)，只使用了常数额外空间

## 执行示例

```text
输入: nums = [2,0,2,1,1,0]

初始状态: [2,0,2,1,1,0]
          ↑     ↑     ↑
        left=0 i=0  right=5

步骤1: i=0, nums[0]=2 (蓝色)
       交换 nums[0] 和 nums[5]
       [0,0,2,1,1,2]
        ↑     ↑   ↑
      left=0 i=0 right=4
      注意：i 不增加，继续判断 nums[0]

步骤2: i=0, nums[0]=0 (红色)
       交换 nums[0] 和 nums[0]（自己和自己交换）
       [0,0,2,1,1,2]
          ↑   ↑   ↑
        left=1 i=1 right=4

步骤3: i=1, nums[1]=0 (红色)
       交换 nums[1] 和 nums[1]
       [0,0,2,1,1,2]
            ↑ ↑   ↑
          left=2 i=2 right=4

步骤4: i=2, nums[2]=2 (蓝色)
       交换 nums[2] 和 nums[4]
       [0,0,1,1,2,2]
            ↑ ↑ ↑
          left=2 i=2 right=3
      注意：i 不增加，继续判断 nums[2]

步骤5: i=2, nums[2]=1 (白色)
       [0,0,1,1,2,2]
            ↑   ↑ ↑
          left=2 i=3 right=3

步骤6: i=3, nums[3]=1 (白色)
       [0,0,1,1,2,2]
            ↑     ↑↑
          left=2 i=4 right=3

步骤7: i=4 > right=3，循环结束

输出: [0,0,1,1,2,2]
```

## 其他解法

### 方法二：计数排序（不满足空间复杂度要求）

先统计 0、1、2 的个数，然后重新填充数组。时间复杂度 O(n)，但需要额外的计数空间。

```javascript
function sortColors(nums) {
  let count0 = 0, count1 = 0, count2 = 0;
  
  // 统计各颜色数量
  for (let num of nums) {
    if (num === 0) count0++;
    else if (num === 1) count1++;
    else count2++;
  }
  
  // 重新填充
  let i = 0;
  while (count0--) nums[i++] = 0;
  while (count1--) nums[i++] = 1;
  while (count2--) nums[i++] = 2;
}
```

**缺点**：需要额外的计数空间，不满足 O(1) 空间复杂度要求。

## 总结

- **最佳方案**：三路快排（双指针法）
- **关键点**：将数组划分为三个区域，使用三个指针维护边界
- **核心技巧**：遇到 2 时交换后不移动 `i`，遇到 0 时交换后移动 `i`
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)
