# 判断链表是否有环

## 问题描述

给定一个链表的头节点 `head`，判断链表中是否存在环。

如果链表中存在环，则返回 `true`；否则，返回 `false`。

**示例 1：**

```text
输入: head = [3,2,0,-4], pos = 1
      3 -> 2 -> 0 -> -4
           ↑          |
           |__________|
输出: true
解释: 链表中存在一个环，其尾部连接到第二个节点（索引为 1）
```

**示例 2：**

```text
输入: head = [1,2], pos = 0
      1 -> 2
      ↑    |
      |____|
输出: true
解释: 链表中存在一个环，其尾部连接到第一个节点（索引为 0）
```

**示例 3：**

```text
输入: head = [1], pos = -1
      1 -> null
输出: false
解释: 链表中不存在环
```

**约束条件：**

- 链表中节点的数目范围是 `[0, 10^4]`
- `-10^5 <= Node.val <= 10^5`
- `pos` 为 `-1` 或者链表中的一个有效索引

## 算法标签

- 双指针 ⭐ (最优解)
- 哈希表
- Floyd 判圈算法（龟兔赛跑算法）

---

## 解法一：快慢指针法（Floyd 判圈算法）⭐

### 复杂度分析

- **时间复杂度：** O(n)，其中 n 是链表中节点的数量
  - 如果链表中没有环，快指针会先到达链表末尾，时间复杂度为 O(n)
  - 如果链表中有环，快慢指针会在环内相遇，时间复杂度为 O(n)
- **空间复杂度：** O(1)，只使用了两个指针的额外空间

### 核心思想

使用两个指针，一个慢指针每次移动一步，一个快指针每次移动两步。如果链表中存在环，快指针最终会追上慢指针（相遇）；如果不存在环，快指针会先到达链表末尾。

### 为什么快慢指针能判断环？

**数学证明：**

假设链表有环，环的长度为 `C`，环的入口到链表头的距离为 `L`。

1. **慢指针进入环时：**
   - 慢指针走了 `L` 步，到达环的入口
   - 快指针走了 `2L` 步，在环内距离入口 `(2L - L) % C = L % C` 的位置

2. **快慢指针在环内：**
   - 慢指针每次走 1 步，快指针每次走 2 步
   - 快指针相对于慢指针的速度是 1 步/次
   - 快指针需要追赶的距离最多为 `C - 1` 步
   - 因此，最多经过 `C - 1` 次移动，快指针就会追上慢指针

3. **结论：**
   - 如果链表有环，快慢指针一定会在环内相遇
   - 如果链表无环，快指针会先到达 `null`

### 算法步骤

1. **边界条件检查：** 如果链表为空或只有一个节点，直接返回 `false`
2. **初始化指针：**
   - `slow = head`：慢指针，每次移动一步
   - `fast = head`：快指针，每次移动两步
3. **遍历链表：**
   - 当 `fast` 和 `fast.next` 都不为空时继续循环
   - 慢指针移动一步：`slow = slow.next`
   - 快指针移动两步：`fast = fast.next.next`
   - 如果 `slow === fast`，说明快慢指针相遇，存在环，返回 `true`
4. **循环结束：** 如果快指针到达链表末尾（`fast` 或 `fast.next` 为 `null`），说明无环，返回 `false`

### 代码实现

```1:17:interview/algorithm/huan/1.js
function hasCycle(head) {
  if (!head || !head.next) return false;

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next; // 慢指针走一步
    fast = fast.next.next; // 快指针走两步

    if (slow === fast) {
      return true; // 快慢指针相遇，说明有环
    }
  }

  return false; // 快指针走到尽头，说明无环
}
```

### 执行示例

```text
示例1: head = [3,2,0,-4], pos = 1
       3 -> 2 -> 0 -> -4
            ↑          |
            |__________|

初始状态:
  slow = 3, fast = 3

第1次移动:
  slow = 2, fast = 0
  3 -> 2(slow) -> 0(fast) -> -4
            ↑          |
            |__________|

第2次移动:
  slow = 0, fast = 2
  3 -> 2(fast) -> 0(slow) -> -4
            ↑          |
            |__________|

第3次移动:
  slow = -4, fast = -4
  3 -> 2 -> 0 -> -4(slow,fast)
            ↑          |
            |__________|
  
slow === fast，返回 true
```

---

## 解法二：哈希表法

### 哈希表法复杂度分析

- **时间复杂度：** O(n)，需要遍历链表一次
- **空间复杂度：** O(n)，最坏情况下需要存储所有节点

### 哈希表法核心思想

使用哈希表（Set）记录已经访问过的节点。遍历链表时，如果当前节点已经在哈希表中，说明存在环；如果遍历到链表末尾都没有重复节点，说明无环。

### 哈希表法算法步骤

1. **初始化：** 创建一个 `Set` 用于存储已访问的节点
2. **遍历链表：**
   - 如果当前节点为 `null`，说明到达链表末尾，返回 `false`
   - 如果当前节点已经在 `Set` 中，说明存在环，返回 `true`
   - 否则，将当前节点加入 `Set`，继续遍历下一个节点

### 哈希表法代码实现

```javascript
function hasCycle(head) {
  const visited = new Set();
  
  while (head) {
    if (visited.has(head)) {
      return true; // 节点已访问过，存在环
    }
    visited.add(head);
    head = head.next;
  }
  
  return false; // 遍历到链表末尾，无环
}
```

### 标记法（修改原链表，不推荐）

也可以通过在节点上添加标记来判断，但这种方法会修改原链表，不推荐使用：

```1:10:interview/algorithm/huan/2.js
const hasCycle = (head) => {
  while (head) {
    if (head.visited) {
      return true;
    }
    head.visited = true;
    head = head.next;
  }
  return false;
};
```

**缺点：** 会修改原链表结构，可能影响后续操作。

---

## 两种方法对比

| 特性 | 快慢指针法 | 哈希表法 |
|------|-----------|---------|
| 时间复杂度 | O(n) | O(n) |
| 空间复杂度 | O(1) ⭐ | O(n) |
| 是否修改原链表 | 否 | 否（标记法会修改） |
| 代码复杂度 | 简单 | 简单 |
| 适用场景 | 生产环境（空间效率高） | 理解哈希表思想 |

---

## 扩展问题

### 如何找到环的入口节点？

在快慢指针相遇后，将一个指针重置到链表头，然后两个指针都以每次一步的速度移动，它们会在环的入口处相遇。

### 找环入口的算法步骤

1. 使用快慢指针找到相遇点
2. 将慢指针重置到 `head`
3. 快慢指针都以每次一步的速度移动
4. 它们相遇的节点就是环的入口

### 找环入口的代码实现

```javascript
function detectCycle(head) {
  if (!head || !head.next) return null;
  
  let slow = head;
  let fast = head;
  
  // 第一步：找到相遇点
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) break;
  }
  
  // 如果没有相遇，说明无环
  if (!fast || !fast.next) return null;
  
  // 第二步：找到环的入口
  slow = head;
  while (slow !== fast) {
    slow = slow.next;
    fast = fast.next;
  }
  
  return slow; // 环的入口节点
}
```

---

## 总结

- **最佳方案：** 快慢指针法（Floyd 判圈算法）
- **核心思想：** 快指针每次走两步，慢指针每次走一步，如果有环，快指针会追上慢指针
- **时间复杂度：** O(n)
- **空间复杂度：** O(1)
- **关键点：** 快指针的速度是慢指针的两倍，确保在有环的情况下一定会相遇
