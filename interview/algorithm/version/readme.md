# 版本号比较

## 题目描述

给你两个版本号 `version1` 和 `version2` ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 `.` 连接。每个修订号由 **多位数字** 组成，可能包含 **前导零** 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，`2.5.33` 和 `0.1` 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 。也就是说，修订号 `1` 和修订号 `001` **相等** 。如果版本号没有指定某个下标处的修订号，则该修订号视为 `0` 。例如，版本 `1.0` 小于版本 `1.1` ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 `0` 和 `1` ，`0 < 1` 。

返回规则如下：

- 如果 `version1 > version2` 返回 `1`，
- 如果 `version1 < version2` 返回 `-1`，
- 除此之外返回 `0`。

## 示例

**示例 1：**

```text
输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"
```

**示例 2：**

```text
输入：version1 = "1.0", version2 = "1.0.0"
输出：0
解释：version1 没有指定下标为 2 的修订号，即视为 "0"
```

**示例 3：**

```text
输入：version1 = "0.1", version2 = "1.1"
输出：-1
解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 < 1，所以 version1 < version2
```

## 解题思路

1. **分割字符串**：首先将两个版本号字符串通过 `.` 分割成数组。
2. **补齐长度**：比较两个数组的长度，取较大值作为循环次数。
3. **逐位比较**：
    - 遍历数组，将每个位置的字符串转换为数字（`Number` 或 `parseInt`）。
    - 如果某个数组在该位置没有值（即越界），则视为 `0`。
    - 比较两个数字的大小：
        - 如果 `num1 > num2`，返回 `1`。
        - 如果 `num1 < num2`，返回 `-1`。
4. **相等情况**：如果循环结束都没有返回，说明两个版本号相等，返回 `0`。

## 代码实现

```javascript
/**
 * @param {string} v1
 * @param {string} v2
 * @return {number}
 */
function compareVersion(v1, v2) {
  // 将版本号字符串分割成数组，并转换为数字
  const v1Arr = v1.split(".").map(Number);
  const v2Arr = v2.split(".").map(Number);
  
  // 获取较长的数组长度
  const len = Math.max(v1Arr.length, v2Arr.length);
  
  for (let i = 0; i < len; i++) {
    // 如果对应位置没有值，则默认为 0
    const num1 = v1Arr[i] || 0;
    const num2 = v2Arr[i] || 0;
    
    if (num1 > num2) return 1;
    if (num1 < num2) return -1;
  }
  
  return 0;
}

// 测试用例
console.log(compareVersion("1.0.0", "1.0.1")); // -1
console.log(compareVersion("1.0.1", "1.0.0")); // 1
console.log(compareVersion("1.0.0", "1.0.0")); // 0
console.log(compareVersion("1.0.0", "1.0.0.1")); // -1
console.log(compareVersion("1.0.0.1", "1.0.0")); // 1
```

## 复杂度分析

- **时间复杂度**：O(N + M + max(N, M))，其中 N 和 M 分别是两个版本号字符串的长度。`split` 操作需要遍历字符串，`map` 需要遍历数组，循环比较需要遍历较长的数组。总体可以看作是线性的。
- **空间复杂度**：O(N + M)，需要存储分割后的数组。
