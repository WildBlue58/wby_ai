# 二叉平衡树的数据结构特点

## 基础概念

### 树 (Tree)

- 相对于链表和栈的线性结构，一种非线性的层次化数据结构
- 由节点和边组成，每个节点最多有一个父节点，可以有多个子节点
- 具有层次性：根节点、内部节点、叶子节点

### 二叉树 (Binary Tree)

- 递归定义：一个根节点，最多有两个子节点（左子树和右子树），而每个子树也是一棵二叉树。
- 每个节点的度不超过2
- 空树也是二叉树

## 二叉搜索树 (BST)

- 左子树所有节点值 < 根节点值 < 右子树所有节点值
- 中序遍历得到有序序列
- 查找、插入、删除时间复杂度：O(h)，h为树高

## 平衡二叉树 (AVL Tree)

### 定义

- 二叉搜索树 + 平衡条件
- 任意节点的左右子树高度差不超过1
- 平衡因子 = 左子树高度 - 右子树高度 ∈ {-1, 0, 1}

### 核心特点

1. **自平衡性**：插入/删除后自动调整保持平衡
2. **严格平衡**：保证树高为 O(log n)
3. **旋转操作**：通过左旋、右旋、左右旋、右左旋维护平衡

### 时间复杂度

- 查找：O(log n)
- 插入：O(log n) + 旋转调整
- 删除：O(log n) + 旋转调整
- 空间：O(n)

### 旋转类型

1. **右旋 (RR)**：左子树过深
2. **左旋 (LL)**：右子树过深  
3. **左右旋 (LR)**：左子树的右子树过深
4. **右左旋 (RL)**：右子树的左子树过深

### 应用场景

- 数据库索引
- 内存中的有序数据结构
- 需要频繁查找且要求稳定性能的场景

### 优缺点

**优点：**

- 查找性能稳定 O(log n)
- 严格平衡，最坏情况可控

**缺点：**

- 插入/删除需要额外旋转开销
- 实现复杂度较高
- 频繁的旋转可能影响性能

## 其他平衡树对比

### 红黑树 vs AVL

- 红黑树：近似平衡，旋转次数少，适合频繁修改
- AVL树：严格平衡，查找性能更好，适合读多写少

### B树/B+树

- 多路平衡树，适合磁盘存储
- 减少磁盘I/O次数
- 数据库索引的经典实现

- 满二叉树
除了叶子节点，每个节点都有两个子节点，且所有叶子结点都在同一层。
2^n - 1

- 完全二叉树
看电影一样，每一排坐满了人，最后一排也是从最左边开始连续坐着，中间不能有空位。

- 二叉搜索树 BST Binary Search Tree
  对于任意结点，其左子树所有结点值小于该结点值，右子树所有结点值大于该结点值。
  高效查找，插入、删除有序数据

- 二叉平衡树
  基于二叉搜索树的，
  约束左右子树的高度差来保持平衡的二叉树。
  线性表的时候O(n)
  二叉搜索树，为了查询的性能提升 O(n) -> O(log2n)
  退化到线性表差不多
  平衡一下

  右旋或左旋

10
    20
        30
  通过左旋，20 提上来，20，10，30 平衡
  AVL 树 二叉平衡树，叶子结点的层级相差不超过1
  为了查询效率而来 BST的优化。

