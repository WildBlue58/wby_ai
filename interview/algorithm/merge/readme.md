# 合并区间

## 问题描述

给定一个区间数组 `intervals`，其中 `intervals[i] = [starti, endi]`。请合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

**示例 1：**

```text
输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]
```

**示例 2：**

```text
输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间
```

## 算法标签

- 递归
- 分治
- 贪心 ⭐ (最优解)
- 动规

## 贪心算法（推荐）

### 核心思想

区别程序逻辑高手有没有算法思想的题目。贪心算法在每一步选择中都采取最优解，希望通过一系列局部最优选择达到全局最优。

### 为什么合并区间是贪心算法？

因为合并区间，按起点排序后，每次将当前区间与已合并的最后一个区间尝试合并。这个"能合并就合并"的局部最优选择，最终能得到最少数量的不重叠区间，符合贪心思想。

### 排序是贪心的基础

- 前面的区间起点不会晚于后面的区间起点
- 排序后，我们只需要考虑：当前节点的起点 <= 已合并最后一个区间的终点
- 如果满足条件，则合并；否则，添加新区间

### 算法步骤

1. **排序**：按区间起点升序排序
2. **初始化**：将第一个区间加入结果数组
3. **遍历**：从第二个区间开始遍历
   - 如果当前区间起点 <= 已合并最后一个区间的终点，则合并（更新终点为两者最大值）
   - 否则，将当前区间加入结果数组

### 代码实现

```1:21:interview/algorithm/merge/1.js
function merge(intervals) {
  if (intervals.length <= 1) return intervals;
  // start 按第一项排序
  // 快排 On(log n)
  intervals.sort((a, b) => a[0] - b[0]);

  const merged = [intervals[0]];
  for (let i = 1; i < intervals.length; i++) {
    const currentInterval = intervals[i];
    const lastMergedInterval = merged[merged.length - 1];
    if (currentInterval[0] <= lastMergedInterval[1]) {
      lastMergedInterval[1] = Math.max(
        lastMergedInterval[1],
        currentInterval[1]
      );
    } else {
      merged.push(currentInterval);
    }
  }
  return merged;
}
```

### 复杂度分析

- **时间复杂度**：O(n log n)，其中 n 是区间数量。排序需要 O(n log n)，遍历需要 O(n)
- **空间复杂度**：O(log n)，排序使用的额外空间。结果数组空间为 O(n)，但通常不计入额外空间

### 执行示例

```text
输入: [[1,3],[2,6],[8,10],[15,18]]

步骤1: 排序后 [[1,3],[2,6],[8,10],[15,18]]
步骤2: merged = [[1,3]]
步骤3: 遍历 [2,6]
       2 <= 3，合并: [1,3] -> [1,6]
步骤4: 遍历 [8,10]
       8 > 6，添加: merged = [[1,6],[8,10]]
步骤5: 遍历 [15,18]
       15 > 10，添加: merged = [[1,6],[8,10],[15,18]]

输出: [[1,6],[8,10],[15,18]]
```

## 其他算法思路

### 递归方法

可以使用递归的方式处理区间合并，但效率不如贪心算法。

**思路**：

- 递归处理子问题
- 每次处理一个区间，与已合并的区间进行比较
- 时间复杂度：O(n²)，空间复杂度：O(n)

### 分治方法

将区间数组分成两部分，分别合并后再合并结果。

**思路**：

- 将区间数组分成左右两部分
- 递归合并左右两部分
- 合并两个已排序的区间数组
- 时间复杂度：O(n log n)，空间复杂度：O(n)

### 动态规划方法

使用动态规划记录状态，但此问题用DP过于复杂，不推荐。

**思路**：

- 定义状态：dp[i] 表示前 i 个区间合并后的结果
- 状态转移：考虑是否合并当前区间
- 时间复杂度：O(n²)，空间复杂度：O(n)

## 总结

- **最佳方案**：贪心算法 + 排序
- **关键点**：排序后只需考虑相邻区间的关系
- **核心判断**：`currentInterval[0] <= lastMergedInterval[1]` 时合并
- **合并规则**：终点取 `Math.max(lastEnd, currentEnd)`
